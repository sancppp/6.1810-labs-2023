# Lock

重写锁。重构xv6的内存分配器&块缓存。
前置：读书
- xv6的第六章-Locking
- Section 3.5: "Code: Physical memory allocator"
- Section 8.1 through 8.3: "Overview", "Buffer cache layer", and "Code: Buffer cache"

## Locking
包括 xv6 在内的大多数内核都会交错执行多个活动。交错执行的一个来源是多处理器硬件：具有多个独立 CPU 的计算机，如 xv6 的 RISC-V。这些多 CPU 共享物理 RAM，xv6 利用共享来维护所有 CPU 都能读写的数据结构。这种共享可能会出现这样的情况：一个 CPU 正在读取一个数据结构，而另一个 CPU 正在更新该数据结构，甚至多个 CPU 同时更新相同的数据；如果没有精心设计，这种并行访问很可能会产生错误的结果或破坏数据结构。即使在单核处理器上，内核也可能在多个线程之间切换 CPU，导致线程执行交错。最后，如果设备中断处理程序与某些可中断代码修改了相同的数据，那么如果中断发生的时间不对，可能会损坏数据。并发一词指的是由于多处理器并行、线程切换或中断等原因导致多条指令流交错执行的情况。  内核中充满了并发访问的数据。例如，两个 CPU 可以同时调用 kalloc，从而同时从空闲列表的头部弹出。内核设计者喜欢允许大量并发，因为这样可以通过并行性提高性能，并增加响应速度。然而，内核设计者必须让自己相信，尽管有这种并发性，也是正确的。获得正确代码的方法有很多，有些方法比其他方法更容易推理。旨在实现并发下正确性的策略以及支持这些策略的抽象概念被称为并发控制技术。  Xv6 根据不同的情况使用了多种并发控制技术；还有更多的并发控制技术有待开发…

总结：
- 多CPU需要共享物理内存...需要共同维护多个在内存中的数据结构。所以，在内核的设计中需要对这些被并行访问的数据结构进行锁保护。确保并发正确性。
- 分析了竞态（race）会引发的问题。两个CPU核同时对维护物理内存页的链表进行操作。
- 如何设计锁？两种类型：自旋（spin）锁&睡眠（sleep）锁。锁的正确性是由CPU提供的CAS原子操作保证的。
- 自旋锁是一个死循环，不断CAS直到成功。睡眠锁涉及到调度。
- 在xv6的实现中，一些耗时小的操作是使用自旋锁保证效率。对磁盘的IO操作则使用睡眠锁
- 6.3-6.4 锁的粒度，获取锁的顺序...更高效的使用锁，以及防止死锁
- 6.5 可重入锁：被一个进程持有，防止递归的时候死锁。
- 6.6 锁与中断处理：当CPU持有锁时被时钟中断打断了，而中断处理程序也要这个锁，则死锁了。所以：中断调度之前prev_task需要放弃所有自旋锁。
- 6.7 需要建立内存屏障，防止乱序执行的优化。__sync_synchronize()
- 6.8 睡眠锁：对IO的操作，对CPU来说很慢，所以要发起调度
- 6.9 现实世界：将锁封装进数据结构中、无锁数据结构。

## 内存分配
kalloc()的锁粒度太大了。导致在频繁申请释放内存的场景下各CPU竞争太大了。
优化思路是：为每个CPU核单独准备一个链表，**需要处理不同CPU核的链表之间调度**
窃取：如果当前CPU核拥有的物理页链表空了，直接在全局找一个物理页。

## b cache lock
修改块缓存，使运行 bcachetest 时，bcache 中所有锁的获取循环迭代次数接近于零。理想情况下，块缓存中所有锁的计数总和应为零，但如果总和小于 500 也没关系。修改 bget 和 brelse，使对 bcache 中不同块的并发查找和释放不太可能发生锁冲突（例如，不必全部等待 bcache.lock）。您必须保持每个块最多缓存一份副本的不变性。完成后，输出结果应与下图类似（但不完全相同）。确保 "usertests -q "仍能通过。完成后，make grade 应能通过所有测试。
我们建议您使用哈希表查找缓存中的块编号，每个哈希桶都有一个锁。

任务：将双向链表改成桶，核心是优化掉全局大资源，改为多个不相干的小资源
总缓存块数要增加，因为如果需要在桶直接调度节点的话，无法操作。？？？
空间换时间